# 性能优化测试指南

## 测试环境准备

### 1. 清除缓存
在测试前，建议清除小程序缓存以获得准确的测试结果：
```javascript
// 在控制台执行
uni.clearStorageSync();
```

### 2. 开启调试模式
在微信开发者工具中：
- 打开 **调试器** → **Console**
- 打开 **调试器** → **Network**
- 打开 **调试器** → **Performance**

---

## 测试场景

### 场景 1：首次进入 Category 页面

**测试步骤**：
1. 清除缓存
2. 重启小程序
3. 点击底部 Tab 切换到 Category 页面
4. 观察加载时间和体验

**预期结果**：
- ✅ 立即显示骨架屏（无白屏）
- ✅ 1-1.5s 内显示实际内容
- ✅ 控制台显示：`🌐 从服务器获取门店分组数据`
- ✅ 控制台显示：`🌐 从服务器获取分类列表`
- ✅ 控制台显示：`🌐 从服务器获取商品列表`

---

### 场景 2：二次进入 Category 页面（缓存命中）

**测试步骤**：
1. 从 Category 页面切换到其他页面（如 Home）
2. 立即切回 Category 页面
3. 观察加载时间和体验

**预期结果**：
- ✅ **几乎瞬间显示**（0.1-0.3s）
- ✅ 无骨架屏（数据已加载）
- ✅ 控制台显示：`✅ 从缓存获取数据: cache_store_groups`
- ✅ 控制台显示：`✅ 从缓存获取数据: cache_category_list`
- ✅ 控制台显示：`✅ 从缓存获取数据: cache_product_list_xxx`
- ✅ Network 面板：**无新的网络请求**

---

### 场景 3：切换学校后刷新数据

**测试步骤**：
1. 在 Category 页面点击学校选择
2. 选择不同的学校
3. 观察数据刷新

**预期结果**：
- ✅ 控制台显示：`🔄 检测到学校变化，重新获取商品数据`
- ✅ 控制台显示：`🗑️ 清理缓存前缀: cache_product_list`
- ✅ 商品列表更新为新学校的商品
- ✅ 刷新过程流畅，无明显卡顿

---

### 场景 4：首次进入 Home 页面

**测试步骤**：
1. 清除缓存
2. 重启小程序
3. 观察首页加载

**预期结果**：
- ✅ 显示全屏加载动画（或骨架屏）
- ✅ 1-1.5s 内显示实际内容
- ✅ 控制台显示：`🌐 从服务器获取门店分组数据`
- ✅ 控制台显示：`🌐 从服务器获取首页内容`

---

### 场景 5：二次进入 Home 页面（缓存命中）

**测试步骤**：
1. 从 Home 页面切换到其他页面
2. 立即切回 Home 页面
3. 观察加载时间

**预期结果**：
- ✅ **几乎瞬间显示**（0.1-0.3s）
- ✅ 控制台显示：`✅ 从缓存获取数据: cache_home_content_xxx`
- ✅ Network 面板：**无新的网络请求**

---

### 场景 6：防抖机制测试

**测试步骤**：
1. 快速切换页面（Home → Category → Home → Category）
2. 观察控制台日志

**预期结果**：
- ✅ 控制台显示：`⏱️ 学校变化检查防抖，跳过`
- ✅ 避免频繁的学校变化检查
- ✅ 切换流畅，无卡顿

---

### 场景 7：图片加载优化测试

**测试步骤**：
1. 在 Category 页面滚动商品列表
2. 观察图片加载
3. 查看 Network 面板的图片请求

**预期结果**：
- ✅ 图片使用缩略图（URL 包含 `x-oss-process` 或 `imageMogr2`）
- ✅ 图片大小明显减小（对比原图）
- ✅ 图片懒加载生效（滚动到可视区域才加载）
- ✅ 加载速度明显提升

---

## 性能指标对比

### 使用 Performance 工具测试

**测试方法**：
1. 打开微信开发者工具的 **Performance** 面板
2. 点击 **Record** 开始录制
3. 执行测试场景
4. 点击 **Stop** 停止录制
5. 分析性能数据

**关键指标**：

| 指标 | 优化前 | 优化后 | 目标 |
|------|--------|--------|------|
| **首次加载时间** | 2-3s | 1-1.5s | < 2s |
| **二次加载时间** | 2-3s | 0.1-0.3s | < 0.5s |
| **白屏时间** | 2-3s | 0s | 0s |
| **网络请求数（二次）** | 3-5个 | 0个 | 0个 |
| **图片大小** | 500KB-2MB | 50KB-200KB | < 300KB |

---

## 控制台日志说明

### 缓存相关日志

```javascript
// ✅ 缓存命中
✅ 从缓存获取数据: cache_store_groups
✅ 门店分组数据加载成功，共 5 个学校

// 🔄 缓存未命中
🔄 缓存未命中，获取新数据: cache_store_groups
🌐 从服务器获取门店分组数据
✅ 门店分组数据加载成功，共 5 个学校

// 🗑️ 缓存清理
🗑️ 清理缓存前缀: cache_product_list, 共清理 3 条
```

### 学校变化日志

```javascript
// ✅ 正常检测
🔄 检测到学校变化，重新获取商品数据 {currentSchoolId: 1, lastSchoolId: 2}

// ⏱️ 防抖跳过
⏱️ 学校变化检查防抖，跳过
```

### 数据加载日志

```javascript
// 🚀 开始加载
🚀 开始获取首页数据，参数: {schoolId: 1}

// 📦 数据响应
📦 首页数据响应: {code: 200, data: {...}}

// ✅ 加载成功
✅ 首页数据内容: {...}
✅ 分类列表加载成功，共 10 个分类
✅ 二级分类加载成功，共 5 个
```

---

## 常见问题排查

### 问题 1：缓存未生效

**症状**：每次切回页面都有网络请求

**排查步骤**：
1. 检查控制台是否有 `✅ 从缓存获取数据` 日志
2. 检查是否清除了缓存（`cacheManager.clear()`）
3. 检查缓存是否过期（查看 `CACHE_EXPIRE_TIME` 配置）

**解决方案**：
```javascript
// 检查缓存状态
console.log('缓存是否存在:', cacheManager.has(CACHE_KEYS.STORE_GROUPS));

// 手动设置缓存
cacheManager.set(CACHE_KEYS.STORE_GROUPS, data, CACHE_EXPIRE_TIME.LONG);
```

---

### 问题 2：骨架屏未显示

**症状**：仍然出现白屏

**排查步骤**：
1. 检查 `dataLoaded` 状态是否正确
2. 检查骨架屏组件是否正确引入
3. 检查 `v-show` 是否正确使用

**解决方案**：
```vue
<!-- 确保使用 v-show 而不是 v-if -->
<skeleton-screen :visible="!dataLoaded" type="category" />
<view v-show="dataLoaded" class="main-container">
  <!-- 内容 -->
</view>
```

---

### 问题 3：图片缩略图未生效

**症状**：图片仍然很大，加载慢

**排查步骤**：
1. 检查图片URL是否包含缩略图参数
2. 检查CDN是否支持缩略图
3. 查看 Network 面板的图片请求

**解决方案**：
```javascript
// 检查缩略图URL
console.log('原图:', item.pic);
console.log('缩略图:', this.getProductThumbnail(item.pic));

// 如果CDN不支持，需要在 lazyLoad.js 中添加规则
```

---

### 问题 4：防抖未生效

**症状**：频繁触发学校变化检查

**排查步骤**：
1. 检查是否调用了 `checkSchoolChangeDebounced()`
2. 检查 `schoolChangeDebounceTime` 配置
3. 查看控制台是否有防抖日志

**解决方案**：
```javascript
// 确保调用防抖方法
onShow() {
  this.checkSchoolChangeDebounced(); // ✅ 正确
  // this.checkSchoolChange(); // ❌ 错误
}
```

---

## 性能监控建议

### 1. 添加性能埋点

```javascript
// 在关键位置添加性能监控
const startTime = Date.now();

// ... 执行操作

const endTime = Date.now();
console.log(`操作耗时: ${endTime - startTime}ms`);
```

### 2. 监控缓存命中率

```javascript
// 统计缓存命中率
let cacheHits = 0;
let cacheMisses = 0;

// 在 cacheManager.get() 中统计
if (cachedData) {
  cacheHits++;
} else {
  cacheMisses++;
}

console.log(`缓存命中率: ${(cacheHits / (cacheHits + cacheMisses) * 100).toFixed(2)}%`);
```

### 3. 监控网络请求

```javascript
// 统计网络请求次数
let requestCount = 0;

// 在每次网络请求时统计
requestCount++;
console.log(`网络请求次数: ${requestCount}`);
```

---

## 总结

通过以上测试场景，可以全面验证性能优化的效果：

1. ✅ **缓存机制**：二次加载几乎瞬间完成
2. ✅ **骨架屏**：无白屏，用户体验好
3. ✅ **防抖机制**：避免频繁请求
4. ✅ **图片优化**：加载速度提升 3-5倍

**关键测试点**：
- 🎯 二次加载时间（最重要）
- 🎯 缓存命中率
- 🎯 网络请求次数
- 🎯 图片加载速度

